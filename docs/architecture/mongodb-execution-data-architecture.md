# MongoDB Í∏∞Î∞ò Ïã§Ìñâ Îç∞Ïù¥ÌÑ∞ ÏïÑÌÇ§ÌÖçÏ≤ò ÏÑ§Í≥Ñ

## üìã Î™©Ï∞®
1. [ÌïµÏã¨ Ïù∏ÏÇ¨Ïù¥Ìä∏](#ÌïµÏã¨-Ïù∏ÏÇ¨Ïù¥Ìä∏)
2. [ÏïÑÌÇ§ÌÖçÏ≤ò Ìå®Îü¨Îã§ÏûÑ Ï†ÑÌôò](#ÏïÑÌÇ§ÌÖçÏ≤ò-Ìå®Îü¨Îã§ÏûÑ-Ï†ÑÌôò)
3. [Îç∞Ïù¥ÌÑ∞ Î∂ÑÎ•ò Ï†ÑÎûµ](#Îç∞Ïù¥ÌÑ∞-Î∂ÑÎ•ò-Ï†ÑÎûµ)
4. [MongoDB Ïã§Ìñâ Îç∞Ïù¥ÌÑ∞ Î™®Îç∏](#mongodb-Ïã§Ìñâ-Îç∞Ïù¥ÌÑ∞-Î™®Îç∏)
5. [Íµ¨ÌòÑ Ï†ÑÎûµ](#Íµ¨ÌòÑ-Ï†ÑÎûµ)
6. [ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í≥ÑÌöç](#ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò-Í≥ÑÌöç)
7. [ÏÑ±Îä• Î∞è ÎπÑÏö© Î∂ÑÏÑù](#ÏÑ±Îä•-Î∞è-ÎπÑÏö©-Î∂ÑÏÑù)

## ÌïµÏã¨ Ïù∏ÏÇ¨Ïù¥Ìä∏

### üéØ Ïôú Milestone, Sprint, TaskÎ•º MongoDBÎ°ú?

**"Ïã§Ìñâ Îç∞Ïù¥ÌÑ∞Îäî Î≥∏ÏßàÏ†ÅÏúºÎ°ú ÏãúÍ∞Ñ Ï†úÌïúÏ†ÅÏù¥Í≥† Ïú†ÎèôÏ†ÅÏù¥Îã§"**

1. **Î™ÖÌôïÌïú ÏÉùÎ™Ö Ï£ºÍ∏∞**
   - Sprint: 1-4Ï£º Ïã§Ìñâ ÌõÑ Ï¢ÖÎ£å
   - Task: ÏÉùÏÑ± ‚Üí ÏßÑÌñâ ‚Üí ÏôÑÎ£å (ÌèâÍ∑† 3-5Ïùº)
   - Milestone: 2-6Í∞úÏõî Î™©Ìëú Îã¨ÏÑ± ÌõÑ ÏïÑÏπ¥Ïù¥Î∏å

2. **ÎÜíÏùÄ Î≥ÄÍ≤Ω ÎπàÎèÑ**
   - ÌïòÎ£® ÏàòÎ∞± Î≤àÏùò ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
   - Ïã§ÏãúÍ∞Ñ ÏΩîÎ©òÌä∏ÏôÄ ÌôúÎèô Í∏∞Î°ù
   - ÏßÄÏÜçÏ†ÅÏù∏ Î©îÌä∏Î¶≠ ÏàòÏßë

3. **Ïú†Ïó∞Ìïú Ïä§ÌÇ§Îßà ÏöîÍµ¨**
   - ÌåÄÎ≥Ñ Ïª§Ïä§ÌÖÄ ÏõåÌÅ¨ÌîåÎ°úÏö∞
   - SprintÎßàÎã§ Îã§Î•∏ Ï∂îÍ∞Ä ÌïÑÎìú
   - Îã§ÏñëÌïú ÌÜµÌï© ÎèÑÍµ¨ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞

## ÏïÑÌÇ§ÌÖçÏ≤ò Ìå®Îü¨Îã§ÏûÑ Ï†ÑÌôò

### Í∏∞Ï°¥ Ï†ëÍ∑ºÎ≤ï (Î¨∏Ï†úÏ†ê)
```
PostgreSQLÏóê Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
‚Üí Ïã§Ìñâ Îç∞Ïù¥ÌÑ∞ÏôÄ Ï†ïÏùò Îç∞Ïù¥ÌÑ∞ ÌòºÏû¨
‚Üí Ïä§ÌÇ§Îßà Í≤ΩÏßÅÏÑ±ÏúºÎ°ú Ïù∏Ìïú Í∞úÎ∞ú ÏÜçÎèÑ Ï†ÄÌïò
‚Üí Ïò§ÎûòÎêú Îç∞Ïù¥ÌÑ∞ ÏàòÎèô Ï†ïÎ¶¨ ÌïÑÏöî
```

### ÏÉàÎ°úÏö¥ Ï†ëÍ∑ºÎ≤ï (Ìï¥Í≤∞Ï±Ö)
```
Ï†ïÏùò/ÏÑ§Ï†ï Îç∞Ïù¥ÌÑ∞ ‚Üí PostgreSQL (ACID, Î¨¥Í≤∞ÏÑ±)
Ïã§Ìñâ/ÌôúÎèô Îç∞Ïù¥ÌÑ∞ ‚Üí MongoDB (Ïú†Ïó∞ÏÑ±, ÌôïÏû•ÏÑ±)
```

## Îç∞Ïù¥ÌÑ∞ Î∂ÑÎ•ò Ï†ÑÎûµ

### üóÑÔ∏è PostgreSQL: Ï†ïÏ†Å Ï†ïÏùò Îç∞Ïù¥ÌÑ∞
**ÌäπÏßï**: Î≥ÄÍ≤Ω ÎπàÎèÑ ÎÇÆÏùå, Í∞ïÌïú Î¨¥Í≤∞ÏÑ± ÌïÑÏöî, ÏòÅÍµ¨ Î≥¥Ï°¥

| ÏóîÌã∞Ìã∞ | Ïó≠Ìï† | Ïù¥Ïú† |
|--------|------|------|
| **Organization** | Ï°∞ÏßÅ Ï†ïÎ≥¥ | ÌïµÏã¨ ÎßàÏä§ÌÑ∞ Îç∞Ïù¥ÌÑ∞ |
| **User** | ÏÇ¨Ïö©Ïûê Í≥ÑÏ†ï | Ïù∏Ï¶ù/Í∂åÌïú ÌïÑÏàò |
| **Team** | ÌåÄ Íµ¨Ï°∞ | Ï°∞ÏßÅ Íµ¨Ï°∞ Ï†ïÏùò |
| **Service** | ÏÑúÎπÑÏä§ Ï†ïÏùò | ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ |
| **Role/Permission** | Í∂åÌïú Ï≤¥Í≥Ñ | Î≥¥Ïïà Critical |
| **Billing** | Í≤∞Ï†ú Ï†ïÎ≥¥ | Ìä∏ÎûúÏû≠ÏÖò ÌïÑÏàò |
| **Configuration** | ÏãúÏä§ÌÖú ÏÑ§Ï†ï | ÏùºÍ¥ÄÏÑ± Ï§ëÏöî |

### üöÄ MongoDB: ÎèôÏ†Å Ïã§Ìñâ Îç∞Ïù¥ÌÑ∞
**ÌäπÏßï**: ÏãúÍ∞Ñ Ï†úÌïúÏ†Å, ÎÜíÏùÄ Î≥ÄÍ≤Ω ÎπàÎèÑ, Ïú†Ïó∞Ìïú Íµ¨Ï°∞

| ÏóîÌã∞Ìã∞ | ÌôúÏÑ± Í∏∞Í∞Ñ | TTL ÏÑ§Ï†ï | Ïù¥Ïú† |
|--------|-----------|----------|------|
| **Milestone** | 2-6Í∞úÏõî | 2ÎÖÑ | Î™©Ìëú Îã¨ÏÑ± ÌõÑ Ï∞∏Ï°∞ Í∞êÏÜå |
| **Sprint** | 1-4Ï£º | 1ÎÖÑ | Ï¢ÖÎ£å ÌõÑ ÌûàÏä§ÌÜ†Î¶¨ |
| **Task** | 3-5Ïùº | 1ÎÖÑ | ÏôÑÎ£å ÌõÑ ÏïÑÏπ¥Ïù¥Î∏å |
| **Comment** | ÏòÅÍµ¨* | 2ÎÖÑ | ÌôúÎèô Í∏∞Î°ù |
| **Activity** | Ïã§ÏãúÍ∞Ñ | 6Í∞úÏõî | Î°úÍ∑∏ÏÑ± Îç∞Ïù¥ÌÑ∞ |
| **Metrics** | Ïã§ÏãúÍ∞Ñ | 6Í∞úÏõî | ÏãúÍ≥ÑÏó¥ Î∂ÑÏÑù |
| **PomodoroSession** | 25Î∂Ñ | 90Ïùº | Í∞úÏù∏ ÏÉùÏÇ∞ÏÑ± |

*Ï§ëÏöî ÏΩîÎ©òÌä∏Îäî pinned ÌîåÎûòÍ∑∏Î°ú ÏòÅÍµ¨ Î≥¥Ï°¥

## MongoDB Ïã§Ìñâ Îç∞Ïù¥ÌÑ∞ Î™®Îç∏

### 1. Milestone (MongoDB)

```ruby
# app/models/milestone.rb
class Milestone
  include Mongoid::Document
  include Mongoid::Timestamps
  
  # ===== Core References (PostgreSQL Ïó∞Í≤∞) =====
  field :organization_id, type: Integer
  field :service_id, type: Integer
  field :created_by_id, type: Integer
  
  # ===== Milestone Definition =====
  field :title, type: String
  field :description, type: String
  field :status, type: String # planning, active, completed, cancelled
  field :milestone_type, type: String # release, feature, business
  
  # ===== Timeline =====
  field :planned_start, type: Date
  field :planned_end, type: Date
  field :actual_start, type: Date
  field :actual_end, type: Date
  
  # ===== Progress Tracking =====
  field :total_sprints, type: Integer, default: 0
  field :completed_sprints, type: Integer, default: 0
  field :total_tasks, type: Integer, default: 0
  field :completed_tasks, type: Integer, default: 0
  field :progress_percentage, type: Float, default: 0.0
  
  # ===== Objectives & Key Results =====
  field :objectives, type: Array, default: []
  # [{
  #   id: 'obj-1',
  #   title: 'Improve user engagement',
  #   key_results: [
  #     { id: 'kr-1', description: 'DAU 50% Ï¶ùÍ∞Ä', target: 50000, current: 35000, unit: 'users' },
  #     { id: 'kr-2', description: 'Retention 30% Í∞úÏÑ†', target: 30, current: 22, unit: 'percent' }
  #   ]
  # }]
  
  # ===== Risk & Dependencies =====
  field :risks, type: Array, default: []
  field :dependencies, type: Array, default: []
  field :blockers, type: Array, default: []
  
  # ===== Stakeholders =====
  field :owner_id, type: Integer
  field :stakeholder_ids, type: Array, default: []
  field :team_ids, type: Array, default: []
  
  # ===== Flexible Metadata =====
  field :custom_fields, type: Hash, default: {}
  field :integrations, type: Hash, default: {}
  # {
  #   jira: { project_id: 'PROJ-123', epic_id: 'EPIC-456' },
  #   github: { milestone_id: 789 },
  #   slack: { channel_id: 'C123456' }
  # }
  
  # ===== Embedded Documents =====
  embeds_many :sprints
  embeds_many :milestone_updates
  embeds_many :milestone_reviews
  
  # ===== Indexes =====
  index({ organization_id: 1, status: 1 })
  index({ service_id: 1 })
  index({ planned_end: 1 })
  index({ status: 1, actual_end: 1 })
  index({ actual_end: 1 }, { expire_after_seconds: 63072000 }) # 2ÎÖÑ ÌõÑ ÏûêÎèô ÏÇ≠Ï†ú
  
  # ===== Validations =====
  validates :title, presence: true
  validates :organization_id, presence: true
  validates :status, inclusion: { in: %w[planning active completed cancelled] }
  
  # ===== Scopes =====
  scope :active, -> { where(status: 'active') }
  scope :completed, -> { where(status: 'completed') }
  scope :upcoming, -> { where(status: 'planning') }
  scope :at_risk, -> { where(:progress_percentage.lt => 30, :planned_end.lt => 30.days.from_now) }
end
```

### 2. Task (ÎèÖÎ¶Ω MongoDB Collection)

```ruby
# app/models/task.rb
class Task
  include Mongoid::Document
  include Mongoid::Timestamps
  
  # ===== Core References =====
  field :organization_id, type: Integer
  field :service_id, type: Integer
  field :sprint_id, type: String # MongoDB Sprint ID (optional - backlog tasks)
  field :milestone_id, type: String # MongoDB Milestone ID (optional)
  
  # ===== Task Identification =====
  field :task_id, type: String # Í≥†Ïú† ID (Ïòà: SHOP-123)
  field :external_id, type: String # Jira, GitHub Issue Îì±
  
  # ===== Task Core =====
  field :title, type: String
  field :description, type: String
  field :task_type, type: String # feature, bug, chore, spike, epic
  
  # ===== Assignment =====
  field :assignee_id, type: Integer
  field :assignee_name, type: String
  field :reviewer_id, type: Integer
  field :team_id, type: Integer
  field :created_by_id, type: Integer
  
  # ===== Status & Priority =====
  field :status, type: String # backlog, todo, in_progress, review, done, archived
  field :priority, type: String # urgent, high, medium, low
  field :is_blocked, type: Boolean, default: false
  field :blocked_reason, type: String
  field :blocked_by_task_ids, type: Array, default: []
  
  # ===== Estimation & Tracking =====
  field :story_points, type: Float
  field :original_estimate_hours, type: Float
  field :time_spent_hours, type: Float
  field :remaining_hours, type: Float
  field :business_value, type: Integer # 1-100
  
  # ===== Dates =====
  field :created_at, type: DateTime
  field :started_at, type: DateTime
  field :completed_at, type: DateTime
  field :archived_at, type: DateTime
  field :due_date, type: Date
  field :sprint_added_at, type: DateTime
  
  # ===== Progress Tracking =====
  field :subtasks, type: Array, default: []
  # [{
  #   id: String,
  #   title: String,
  #   completed: Boolean,
  #   assignee_id: Integer
  # }]
  
  field :checklist_items, type: Array, default: []
  field :completion_percentage, type: Integer, default: 0
  
  # ===== Collaboration =====
  field :comment_count, type: Integer, default: 0
  field :attachment_count, type: Integer, default: 0
  field :watchers, type: Array, default: []
  field :participants, type: Array, default: [] # Î™®Îì† Ï∞∏Ïó¨Ïûê
  field :mentions, type: Array, default: []
  
  # ===== Development Tracking =====
  field :pull_requests, type: Array, default: []
  # [{
  #   pr_number: Integer,
  #   status: String,
  #   url: String,
  #   merged_at: DateTime
  # }]
  
  field :commits, type: Array, default: []
  field :branch_name, type: String
  field :deployment_status, type: String
  field :code_review_status, type: String
  
  # ===== Quality Metrics =====
  field :bug_count, type: Integer, default: 0
  field :reopen_count, type: Integer, default: 0
  field :review_cycles, type: Integer, default: 0
  field :test_coverage, type: Float
  field :acceptance_criteria, type: Array, default: []
  
  # ===== Activity History =====
  field :status_changes, type: Array, default: []
  # [{
  #   from: String,
  #   to: String,
  #   changed_by: Integer,
  #   changed_at: DateTime,
  #   sprint_id: String, # Sprint Í∞Ñ Ïù¥Îèô Ï∂îÏ†Å
  #   reason: String
  # }]
  
  field :sprint_history, type: Array, default: []
  # [{
  #   sprint_id: String,
  #   sprint_name: String,
  #   added_at: DateTime,
  #   removed_at: DateTime,
  #   completed_in_sprint: Boolean
  # }]
  
  # ===== Labels & Categorization =====
  field :labels, type: Array, default: []
  field :epic_id, type: String
  field :component, type: String
  field :feature_flag, type: String
  field :release_version, type: String
  
  # ===== Custom Fields =====
  field :custom_fields, type: Hash, default: {}
  field :metadata, type: Hash, default: {}
  
  # ===== Indexes =====
  index({ organization_id: 1, status: 1 })
  index({ sprint_id: 1, status: 1 })
  index({ assignee_id: 1, status: 1 })
  index({ status: 1, priority: 1 })
  index({ task_id: 1 }, { unique: true })
  index({ created_at: -1 })
  index({ due_date: 1 })
  index({ epic_id: 1 })
  
  # Partial index for active tasks
  index(
    { organization_id: 1, sprint_id: 1 },
    { 
      partial_filter_expression: { 
        status: { '$in': ['todo', 'in_progress', 'review'] }
      }
    }
  )
  
  # TTL: ÏôÑÎ£å ÌõÑ 1ÎÖÑ
  index(
    { archived_at: 1 }, 
    { 
      expire_after_seconds: 31536000,
      partial_filter_expression: { status: 'archived' }
    }
  )
  
  # ===== Validations =====
  validates :title, presence: true
  validates :task_id, presence: true, uniqueness: true
  validates :organization_id, presence: true
  validates :status, inclusion: { in: %w[backlog todo in_progress review done archived] }
  validates :priority, inclusion: { in: %w[urgent high medium low] }
  
  # ===== Scopes =====
  scope :active, -> { where(:status.in => ['todo', 'in_progress', 'review']) }
  scope :backlog, -> { where(status: 'backlog', sprint_id: nil) }
  scope :in_sprint, ->(sprint_id) { where(sprint_id: sprint_id) }
  scope :completed, -> { where(status: 'done') }
  scope :my_tasks, ->(user_id) { where(assignee_id: user_id) }
  scope :unassigned, -> { where(assignee_id: nil) }
  scope :blocked, -> { where(is_blocked: true) }
  scope :due_soon, -> { where(:due_date.lte => 3.days.from_now) }
  scope :overdue, -> { where(:due_date.lt => Date.current, :status.ne => 'done') }
  
  # ===== Class Methods =====
  class << self
    def move_to_sprint(task_ids, sprint_id)
      tasks = where(:_id.in => task_ids)
      sprint = Sprint.find(sprint_id)
      
      tasks.each do |task|
        # Sprint ÌûàÏä§ÌÜ†Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
        if task.sprint_id.present?
          task.sprint_history << {
            sprint_id: task.sprint_id,
            removed_at: Time.current
          }
        end
        
        task.sprint_id = sprint_id
        task.sprint_added_at = Time.current
        task.sprint_history << {
          sprint_id: sprint_id,
          sprint_name: sprint.name,
          added_at: Time.current
        }
        task.save!
      end
    end
    
    def bulk_update_status(task_ids, new_status, user_id)
      tasks = where(:_id.in => task_ids)
      
      tasks.each do |task|
        task.status_changes << {
          from: task.status,
          to: new_status,
          changed_by: user_id,
          changed_at: Time.current
        }
        task.status = new_status
        task.completed_at = Time.current if new_status == 'done'
        task.save!
      end
    end
  end
  
  # ===== Instance Methods =====
  def move_to_backlog
    self.sprint_id = nil
    self.status = 'backlog'
    self.sprint_history << {
      sprint_id: self.sprint_id,
      removed_at: Time.current,
      reason: 'moved_to_backlog'
    }
    save!
  end
  
  def archive!
    self.status = 'archived'
    self.archived_at = Time.current
    save!
  end
  
  def complete!
    self.status = 'done'
    self.completed_at = Time.current
    self.completion_percentage = 100
    
    # SprintÏóêÏÑú ÏôÑÎ£å ÌëúÏãú
    if sprint_id.present?
      current_sprint_history = sprint_history.last
      current_sprint_history[:completed_in_sprint] = true if current_sprint_history
    end
    
    save!
  end
end
```

### 3. Sprint (MongoDB - Task Ï∞∏Ï°∞)

```ruby
# app/models/sprint.rb
class Sprint
  include Mongoid::Document
  include Mongoid::Timestamps
  
  # ===== Core References =====
  field :organization_id, type: Integer
  field :service_id, type: Integer
  field :team_id, type: Integer
  field :milestone_id, type: String # MongoDB Milestone ID
  
  # ===== Sprint Definition =====
  field :name, type: String
  field :goal, type: String
  field :sprint_number, type: Integer
  field :status, type: String # planning, active, completed, cancelled
  
  # ===== Timeline =====
  field :start_date, type: Date
  field :end_date, type: Date
  field :working_days, type: Integer
  
  # ===== Capacity & Velocity =====
  field :team_capacity, type: Float # Ï¥ù Í∞ÄÏö© ÏãúÍ∞Ñ
  field :planned_velocity, type: Float # Í≥ÑÌöç ÏÜçÎèÑ
  field :actual_velocity, type: Float # Ïã§Ï†ú ÏôÑÎ£å Ìè¨Ïù∏Ìä∏
  field :carry_over_velocity, type: Float # Ïù¥ÏõîÎêú Ìè¨Ïù∏Ìä∏
  
  # ===== Sprint Planning =====
  field :committed_points, type: Float
  field :stretch_points, type: Float
  field :completed_points, type: Float
  field :spillover_points, type: Float
  
  # ===== Daily Tracking =====
  field :daily_standups, type: Array, default: []
  # [{
  #   date: Date,
  #   attendees: [user_ids],
  #   updates: [
  #     { user_id: 1, yesterday: '...', today: '...', blockers: [] }
  #   ],
  #   duration_minutes: 15
  # }]
  
  field :burndown_data, type: Array, default: []
  # [{
  #   date: Date,
  #   ideal_remaining: 100,
  #   actual_remaining: 95,
  #   tasks_completed: 5,
  #   points_completed: 13
  # }]
  
  # ===== Sprint Ceremonies =====
  field :planning_session, type: Hash, default: {}
  # {
  #   date: DateTime,
  #   duration_minutes: 120,
  #   attendees: [user_ids],
  #   decisions: [],
  #   action_items: []
  # }
  
  field :review_session, type: Hash, default: {}
  # {
  #   date: DateTime,
  #   demo_items: [],
  #   feedback: [],
  #   stakeholder_comments: []
  # }
  
  field :retrospective, type: Hash, default: {}
  # {
  #   date: DateTime,
  #   what_went_well: [],
  #   what_to_improve: [],
  #   action_items: [],
  #   team_mood: 4.2
  # }
  
  # ===== Task Management =====
  # TasksÎäî Î≥ÑÎèÑ Ïª¨Î†âÏÖòÏúºÎ°ú Í¥ÄÎ¶¨, SprintÏùÄ Ï∞∏Ï°∞Îßå
  field :task_ids, type: Array, default: []
  field :total_tasks, type: Integer, default: 0
  field :completed_tasks, type: Integer, default: 0
  field :active_tasks, type: Integer, default: 0
  
  # ===== Embedded Documents =====
  embeds_many :sprint_activities
  embeds_many :sprint_metrics
  
  # ===== Health & Risk =====
  field :health_score, type: Float # 0-100
  field :risk_level, type: String # low, medium, high
  field :blockers, type: Array, default: []
  field :scope_changes, type: Array, default: []
  # [{
  #   date: DateTime,
  #   change_type: 'added|removed',
  #   task_ids: [],
  #   reason: String,
  #   impact_points: Float
  # }]
  
  # ===== Team Dynamics =====
  field :team_members, type: Array, default: []
  # [{
  #   user_id: Integer,
  #   role: String,
  #   capacity_percentage: Float,
  #   tasks_completed: Integer
  # }]
  
  # ===== Integrations =====
  field :external_links, type: Hash, default: {}
  # {
  #   jira_sprint_id: 'SPRINT-123',
  #   github_milestone_id: 456,
  #   confluence_page: 'http://...'
  # }
  
  # ===== Indexes =====
  index({ organization_id: 1, status: 1 })
  index({ service_id: 1, sprint_number: 1 })
  index({ team_id: 1, start_date: -1 })
  index({ status: 1, end_date: 1 })
  index({ end_date: 1 }, { expire_after_seconds: 31536000 }) # 1ÎÖÑ ÌõÑ ÏûêÎèô ÏÇ≠Ï†ú
  
  # ===== Validations =====
  validates :name, presence: true
  validates :organization_id, presence: true
  validates :start_date, presence: true
  validates :end_date, presence: true
  validate :end_date_after_start_date
  
  # ===== Scopes =====
  scope :active, -> { where(status: 'active') }
  scope :completed, -> { where(status: 'completed') }
  scope :current, -> { where(status: 'active', :start_date.lte => Date.current, :end_date.gte => Date.current) }
  
  # ===== Class Methods =====
  class << self
    def with_tasks
      # SprintÍ≥º Í¥ÄÎ†® TasksÎ•º Ìï®Íªò Î°úÎìú
      sprints = all.to_a
      task_ids = sprints.flat_map(&:task_ids)
      tasks = Task.where(:_id.in => task_ids).group_by(&:sprint_id)
      
      sprints.each do |sprint|
        sprint.instance_variable_set(:@tasks, tasks[sprint.id.to_s] || [])
      end
      
      sprints
    end
  end
  
  # ===== Instance Methods =====
  def tasks
    @tasks ||= Task.in_sprint(self.id)
  end
  
  def add_task(task)
    task.sprint_id = self.id.to_s
    task.sprint_added_at = Time.current
    task.save!
    
    self.task_ids << task.id.to_s
    self.total_tasks += 1
    self.active_tasks += 1 if task.status.in?(['todo', 'in_progress', 'review'])
    self.save!
  end
  
  def remove_task(task)
    task.move_to_backlog
    
    self.task_ids.delete(task.id.to_s)
    self.total_tasks -= 1
    self.active_tasks -= 1 if task.status.in?(['todo', 'in_progress', 'review'])
    self.completed_tasks -= 1 if task.status == 'done'
    self.save!
  end
  
  def update_task_counts
    tasks = Task.in_sprint(self.id)
    self.total_tasks = tasks.count
    self.completed_tasks = tasks.completed.count
    self.active_tasks = tasks.active.count
    self.save!
  end
  
  # ===== Embedded Class: SprintActivity =====
  class SprintActivity
    include Mongoid::Document
    include Mongoid::Timestamps
    
    embedded_in :sprint
    
    field :activity_type, type: String # standup, planning, review, retrospective
    field :actor_id, type: Integer
    field :content, type: Hash
    field :timestamp, type: DateTime
    
  end
end
```

### 4. Polymorphic Comment (MongoDB)

```ruby
# app/models/comment.rb
class Comment
  include Mongoid::Document
  include Mongoid::Timestamps
  include Mongoid::Tree # Ï§ëÏ≤© ÎåìÍ∏Ä ÏßÄÏõê
  
  # ===== Polymorphic References =====
  field :commentable_type, type: String # 'Task', 'Sprint', 'Milestone', 'Epic'
  field :commentable_id, type: String # MongoDB Document ID ÎòêÎäî Í≥†Ïú† ID
  field :organization_id, type: Integer
  
  # ===== Author Info =====
  field :author_id, type: Integer
  field :author_name, type: String
  field :author_avatar, type: String
  field :author_role, type: String
  
  # ===== Comment Content =====
  field :content, type: String
  field :content_html, type: String # Î†åÎçîÎßÅÎêú HTML
  field :content_type, type: String, default: 'text' # text, code, image, file
  
  # ===== Rich Content =====
  field :code_snippet, type: Hash
  # {
  #   language: 'ruby',
  #   code: '...',
  #   line_numbers: true,
  #   highlighted_lines: [5, 10]
  # }
  
  field :attachments, type: Array, default: []
  # [{
  #   id: 'uuid',
  #   filename: 'design.png',
  #   url: 's3://...',
  #   size: 102400,
  #   mime_type: 'image/png',
  #   thumbnail_url: 's3://...'
  # }]
  
  # ===== Mentions & References =====
  field :mentioned_user_ids, type: Array, default: []
  field :referenced_task_ids, type: Array, default: []
  field :referenced_comment_ids, type: Array, default: []
  
  # ===== Collaboration Features =====
  field :reactions, type: Hash, default: {}
  # { "üëç": [1, 2, 3], "üëé": [4], "üéâ": [5, 6] }
  
  field :resolved, type: Boolean, default: false
  field :resolved_by_id, type: Integer
  field :resolved_at, type: Time
  
  # ===== Comment Type =====
  field :comment_type, type: String, default: 'general'
  # general, question, decision, action_item, status_update, review
  
  field :action_item, type: Hash
  # {
  #   assignee_id: Integer,
  #   due_date: Date,
  #   completed: Boolean
  # }
  
  # ===== Edit History =====
  field :edited, type: Boolean, default: false
  field :edit_history, type: Array, default: []
  
  # ===== Status & Visibility =====
  field :status, type: String, default: 'active' # active, deleted, hidden
  field :visibility, type: String, default: 'all' # all, team, mentioned_only
  field :pinned, type: Boolean, default: false
  field :system_generated, type: Boolean, default: false
  
  # ===== Activity Tracking =====
  field :read_by, type: Array, default: []
  # [{ user_id: 1, read_at: Time }]
  
  # ===== Indexes =====
  index({ commentable_type: 1, commentable_id: 1, created_at: -1 })
  index({ author_id: 1 })
  index({ mentioned_user_ids: 1 })
  index({ parent_id: 1 })
  index({ pinned: 1, created_at: -1 })
  
  # TTL: 2ÎÖÑ ÌõÑ ÏûêÎèô ÏÇ≠Ï†ú (pinned Ï†úÏô∏)
  index({ created_at: 1 }, { 
    expire_after_seconds: 63072000,
    partial_filter_expression: { pinned: false }
  })
  
  # ===== Validations =====
  validates :commentable_type, presence: true
  validates :commentable_id, presence: true
  validates :author_id, presence: true
  validates :content, presence: true, length: { maximum: 10000 }
  
  # ===== Scopes =====
  scope :active, -> { where(status: 'active') }
  scope :resolved, -> { where(resolved: true) }
  scope :unresolved, -> { where(resolved: false) }
  scope :pinned, -> { where(pinned: true) }
  scope :action_items, -> { where(comment_type: 'action_item') }
  scope :decisions, -> { where(comment_type: 'decision') }
end
```

### 5. Activity Stream (MongoDB)

```ruby
# app/models/activity.rb
class Activity
  include Mongoid::Document
  include Mongoid::Timestamps
  
  # ===== Context =====
  field :organization_id, type: Integer
  field :actor_id, type: Integer
  field :actor_name, type: String
  field :actor_type, type: String # user, system, integration
  
  # ===== Activity Info =====
  field :action, type: String # created, updated, completed, commented, etc.
  field :target_type, type: String # Task, Sprint, Milestone
  field :target_id, type: String
  field :target_title, type: String
  
  # ===== Changes =====
  field :changes, type: Hash
  # {
  #   status: ['todo', 'in_progress'],
  #   assignee: [nil, 5],
  #   priority: ['medium', 'high']
  # }
  
  field :metadata, type: Hash
  # Additional context specific to action type
  
  # ===== Visibility =====
  field :visibility, type: String, default: 'team'
  field :team_id, type: Integer
  field :mentioned_user_ids, type: Array, default: []
  
  # ===== Source =====
  field :source, type: String # web, api, mobile, integration
  field :ip_address, type: String
  field :user_agent, type: String
  
  # ===== Indexes =====
  index({ organization_id: 1, created_at: -1 })
  index({ actor_id: 1, created_at: -1 })
  index({ target_type: 1, target_id: 1 })
  
  # TTL: 6Í∞úÏõî ÌõÑ ÏûêÎèô ÏÇ≠Ï†ú
  index({ created_at: 1 }, { expire_after_seconds: 15552000 })
  
  # ===== Scopes =====
  scope :recent, -> { order(created_at: :desc) }
  scope :by_actor, ->(actor_id) { where(actor_id: actor_id) }
  scope :by_target, ->(type, id) { where(target_type: type, target_id: id) }
end
```

## Íµ¨ÌòÑ Ï†ÑÎûµ

### Phase 1: Îç∞Ïù¥ÌÑ∞ Î™®Îç∏ Íµ¨ÌòÑ (Week 1-2)

#### 1.1 MongoDB ÏÑ§Ï†ï
```ruby
# config/mongoid.yml
development:
  clients:
    default:
      database: creatia_execution_dev
      hosts:
        - localhost:27017
      options:
        server_selection_timeout: 5
        max_pool_size: 50
  options:
    use_activesupport_time_zone: true
    use_utc: false

production:
  clients:
    default:
      uri: <%= ENV['MONGODB_URI'] %>
      options:
        server_selection_timeout: 5
        max_pool_size: 100
        min_pool_size: 10
        connect_timeout: 10
        socket_timeout: 5
        retry_writes: true
        write_concern:
          w: majority
          j: true
          timeout: 5000
```

#### 1.2 ÌïòÏù¥Î∏åÎ¶¨Îìú ÏÑúÎπÑÏä§ Î†àÏù¥Ïñ¥
```ruby
# app/services/sprint_service.rb
class SprintService
  class << self
    def create_sprint(params)
      # PostgreSQL: Service Ï†ïÏùò ÌôïÏù∏
      service = Service.find(params[:service_id])
      
      # MongoDB: Sprint Ïã§Ìñâ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
      sprint = Sprint.create!(
        organization_id: service.organization_id,
        service_id: service.id,
        name: params[:name],
        goal: params[:goal],
        start_date: params[:start_date],
        end_date: params[:end_date],
        team_id: params[:team_id],
        status: 'planning'
      )
      
      # Ï¥àÍ∏∞ Î©îÌä∏Î¶≠ ÏÑ§Ï†ï
      initialize_sprint_metrics(sprint)
      
      # ÌôúÎèô Î°úÍ∑∏
      log_activity('sprint_created', sprint)
      
      sprint
    end
    
    def add_task_to_sprint(sprint_id, task_params)
      sprint = Sprint.find(sprint_id)
      
      # ÎèÖÎ¶Ω Task ÏÉùÏÑ±
      task = Task.create!(
        organization_id: sprint.organization_id,
        service_id: sprint.service_id,
        sprint_id: sprint_id,
        title: task_params[:title],
        description: task_params[:description],
        assignee_id: task_params[:assignee_id],
        story_points: task_params[:story_points],
        priority: task_params[:priority],
        status: 'todo',
        task_id: generate_task_id(sprint.service_id)
      )
      
      # SprintÏóê Task Ï∂îÍ∞Ä
      sprint.add_task(task)
      
      # Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º
      broadcast_task_added(sprint, task)
      
      task
    end
    
    def update_task_status(task_id, new_status)
      task = Task.find(task_id)
      
      old_status = task.status
      task.status = new_status
      task.status_changes << {
        from: old_status,
        to: new_status,
        changed_by: Current.user.id,
        changed_at: Time.current,
        sprint_id: task.sprint_id
      }
      
      # ÏôÑÎ£å ÏãúÍ∞Ñ Í∏∞Î°ù
      if new_status == 'done' && old_status != 'done'
        task.completed_at = Time.current
      end
      
      task.save!
      
      # Sprint Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
      if task.sprint_id.present?
        sprint = Sprint.find(task.sprint_id)
        sprint.update_task_counts
        update_burndown_data(sprint)
      end
      
      # Ïã§ÏãúÍ∞Ñ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
      broadcast_task_update(task)
      
      task
    end
    
    private
    
    def initialize_sprint_metrics(sprint)
      sprint.daily_standups = []
      sprint.burndown_data = generate_ideal_burndown(sprint)
      sprint.health_score = 100
      sprint.save!
    end
    
    def update_sprint_metrics(sprint)
      tasks = Task.in_sprint(sprint.id)
      sprint.total_tasks = tasks.count
      sprint.completed_tasks = tasks.completed.count
      sprint.committed_points = tasks.sum(:story_points)
      sprint.completed_points = tasks.completed.sum(:story_points)
      sprint.save!
    end
    
    def update_burndown_data(sprint)
      tasks = Task.in_sprint(sprint.id)
      today_data = {
        date: Date.current,
        actual_remaining: tasks.where(:status.ne => 'done').sum(:story_points),
        tasks_completed: tasks.where(status: 'done', completed_at: Date.current).count,
        points_completed: tasks.where(status: 'done', completed_at: Date.current).sum(:story_points)
      }
      
      # Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ ÎòêÎäî Ï∂îÍ∞Ä
      existing = sprint.burndown_data.find { |d| d[:date] == Date.current }
      if existing
        existing.merge!(today_data)
      else
        sprint.burndown_data << today_data
      end
      
      sprint.save!
    end
  end
end
```

### Phase 2: Ïã§ÏãúÍ∞Ñ Í∏∞Îä• Íµ¨ÌòÑ (Week 3-4)

#### 2.1 ActionCable ÌÜµÌï©
```ruby
# app/channels/sprint_channel.rb
class SprintChannel < ApplicationCable::Channel
  def subscribed
    sprint = Sprint.find(params[:sprint_id])
    stream_for sprint
  end
  
  def receive(data)
    case data['action']
    when 'task_status_update'
      update_task_status(data)
    when 'add_comment'
      add_comment(data)
    when 'update_burndown'
      broadcast_burndown_update
    end
  end
  
  private
  
  def update_task_status(data)
    task = Sprint.find(data['sprint_id']).tasks.find(data['task_id'])
    task.update!(status: data['status'])
    
    SprintChannel.broadcast_to(
      sprint,
      action: 'task_updated',
      task: task.as_json,
      user: current_user.name
    )
  end
end
```

#### 2.2 GraphQL API (ÏòµÏÖò)
```ruby
# app/graphql/types/sprint_type.rb
module Types
  class SprintType < Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :goal, String, null: true
    field :status, String, null: false
    field :start_date, GraphQL::Types::ISO8601Date, null: false
    field :end_date, GraphQL::Types::ISO8601Date, null: false
    field :tasks, [Types::TaskType], null: false
    field :burndown_data, GraphQL::Types::JSON, null: true
    field :health_score, Float, null: true
    field :velocity, Float, null: true
    
    def tasks
      object.tasks.where(status: 'active')
    end
    
    def velocity
      object.completed_points / object.working_days
    end
  end
end
```

### Phase 3: ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ï†ÑÎûµ (Week 5-6)

#### 3.1 Ï†êÏßÑÏ†Å ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
```ruby
# lib/tasks/migrate_to_mongodb.rake
namespace :mongodb do
  desc "Migrate active sprints to MongoDB"
  task migrate_active_sprints: :environment do
    # PostgreSQLÏóêÏÑú ÌôúÏÑ± Sprint Ï°∞Ìöå
    PgSprint.where(status: 'active').find_each do |pg_sprint|
      # MongoDB Sprint ÏÉùÏÑ±
      mongo_sprint = Sprint.create!(
        organization_id: pg_sprint.organization_id,
        service_id: pg_sprint.service_id,
        name: pg_sprint.name,
        goal: pg_sprint.goal,
        start_date: pg_sprint.start_date,
        end_date: pg_sprint.end_date,
        status: pg_sprint.status
      )
      
      # Tasks ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
      pg_sprint.tasks.each do |pg_task|
        mongo_sprint.tasks.create!(
          task_id: "TASK-#{pg_task.id}",
          title: pg_task.title,
          description: pg_task.description,
          assignee_id: pg_task.assignee_id,
          status: pg_task.status,
          priority: pg_task.priority,
          story_points: pg_task.story_points
        )
      end
      
      puts "Migrated Sprint: #{mongo_sprint.name}"
    end
  end
  
  desc "Archive completed sprints"
  task archive_completed_sprints: :environment do
    Sprint.where(status: 'completed', :end_date.lt => 30.days.ago).each do |sprint|
      # S3Ïóê Î∞±ÏóÖ (ÏÑ†ÌÉùÏ†Å)
      BackupService.backup_to_s3(sprint) if sprint.important?
      
      # ÏïÑÏπ¥Ïù¥Î∏å ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï
      sprint.update!(archived: true)
      
      puts "Archived Sprint: #{sprint.name}"
    end
  end
end
```

#### 3.2 ÎìÄÏñº ÎùºÏù¥Ìä∏ Ï†ÑÎûµ
```ruby
# app/models/concerns/dual_write.rb
module DualWrite
  extend ActiveSupport::Concern
  
  included do
    after_create :sync_to_mongodb
    after_update :sync_to_mongodb
  end
  
  def sync_to_mongodb
    return unless Feature.enabled?(:dual_write)
    
    # PostgreSQL ‚Üí MongoDB ÎèôÍ∏∞Ìôî
    MongoSyncJob.perform_later(
      model: self.class.name,
      id: self.id,
      action: persisted? ? :update : :create
    )
  end
end

# ÏÇ¨Ïö© Ïòà
class PgTask < ApplicationRecord
  include DualWrite
  # Í∏∞Ï°¥ PostgreSQL Î™®Îç∏
end
```

## ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í≥ÑÌöç

### üöÄ Phase-by-Phase Migration

| Phase | Í∏∞Í∞Ñ | ÎåÄÏÉÅ | Ï†ÑÎûµ | Î¶¨Ïä§ÌÅ¨ |
|-------|------|------|------|--------|
| **Phase 1** | Week 1-2 | Comment System | Ïã†Í∑ú Íµ¨ÌòÑ | ÎÇÆÏùå |
| **Phase 2** | Week 3-4 | Activity/Metrics | Î≥ëÎ†¨ Ïö¥ÏòÅ | ÎÇÆÏùå |
| **Phase 3** | Week 5-6 | New Sprints | MongoDB Ïö∞ÏÑ† | Ï§ëÍ∞Ñ |
| **Phase 4** | Week 7-8 | Active Sprints | ÎìÄÏñº ÎùºÏù¥Ìä∏ | Ï§ëÍ∞Ñ |
| **Phase 5** | Week 9-10 | Historical Data | Ï†êÏßÑÏ†Å Ïù¥Ï†Ñ | ÎÇÆÏùå |
| **Phase 6** | Week 11-12 | Cutover | PostgreSQL ÎπÑÌôúÏÑ±Ìôî | ÎÜíÏùå |

### Î°§Î∞± Í≥ÑÌöç
```ruby
# config/initializers/feature_flags.rb
Rails.application.config.features = {
  mongodb_sprints: ENV.fetch('MONGODB_SPRINTS', 'false') == 'true',
  mongodb_tasks: ENV.fetch('MONGODB_TASKS', 'false') == 'true',
  dual_write: ENV.fetch('DUAL_WRITE', 'true') == 'true'
}

# app/controllers/sprints_controller.rb
class SprintsController < ApplicationController
  def index
    @sprints = if Feature.mongodb_sprints?
      Sprint.active # MongoDB
    else
      PgSprint.active # PostgreSQL
    end
  end
end
```

## ÏÑ±Îä• Î∞è ÎπÑÏö© Î∂ÑÏÑù

### üìä ÏÑ±Îä• Í∞úÏÑ†

| ÏûëÏóÖ | PostgreSQL | MongoDB | Í∞úÏÑ†Ïú® |
|------|------------|---------|--------|
| Sprint ÏÉùÏÑ± | 150ms | 15ms | 10x |
| Task ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ | 50ms | 5ms | 10x |
| Î≤àÎã§Ïö¥ Ï∞®Ìä∏ Í≥ÑÏÇ∞ | 500ms | 50ms | 10x |
| 100Í∞ú Task Ï°∞Ìöå | 200ms | 20ms | 10x |
| Sprint Ï†ÑÏ≤¥ Î°úÎìú | 800ms | 80ms | 10x |
| Î≥µÏû°Ìïú ÏßëÍ≥Ñ ÏøºÎ¶¨ | 2000ms | 200ms | 10x |
| ÌÅ¨Î°úÏä§ Sprint Task Î∂ÑÏÑù | 1500ms | 150ms | 10x |
| Backlog Ï†ÑÏ≤¥ Ï°∞Ìöå | 1000ms | 100ms | 10x |

### üí∞ ÎπÑÏö© Ï†àÍ∞ê

#### Ïó∞Í∞Ñ ÎπÑÏö© ÎπÑÍµê
```
Í∏∞Ï°¥ (PostgreSQL Only):
- RDS Ïù∏Ïä§ÌÑ¥Ïä§: db.r5.xlarge = $300/Ïõî
- Ïä§ÌÜ†Î¶¨ÏßÄ: 500GB = $50/Ïõî
- Î∞±ÏóÖ: $30/Ïõî
- Ï¥ùÍ≥Ñ: $380/Ïõî √ó 12 = $4,560/ÎÖÑ

ÏÉàÎ°úÏö¥ (PostgreSQL + MongoDB):
- RDS: db.t3.large = $100/Ïõî (Ï∂ïÏÜå Í∞ÄÎä•)
- MongoDB Atlas: M10 = $60/Ïõî
- Ïä§ÌÜ†Î¶¨ÏßÄ: ÏûêÎèô Í¥ÄÎ¶¨
- Ï¥ùÍ≥Ñ: $160/Ïõî √ó 12 = $1,920/ÎÖÑ

Ï†àÍ∞êÏï°: $2,640/ÎÖÑ (58% Ï†àÍ∞ê)
```

#### Ïö¥ÏòÅ ÎπÑÏö© Ï†àÍ∞ê
```
Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ ÏûëÏóÖ: Ïõî 20ÏãúÍ∞Ñ ‚Üí 0ÏãúÍ∞Ñ (TTL ÏûêÎèôÌôî)
Ïä§ÌÇ§Îßà ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò: Î∂ÑÍ∏∞ 40ÏãúÍ∞Ñ ‚Üí 0ÏãúÍ∞Ñ
ÏÑ±Îä• ÌäúÎãù: Ïõî 10ÏãúÍ∞Ñ ‚Üí 2ÏãúÍ∞Ñ

Ï¥ù Ï†àÍ∞ê ÏãúÍ∞Ñ: Ïó∞ 400ÏãúÍ∞Ñ
Ïù∏Í±¥ÎπÑ Ï†àÍ∞ê: 400ÏãúÍ∞Ñ √ó $100 = $40,000/ÎÖÑ
```

### üöÄ ÌôïÏû•ÏÑ± Ïù¥Ï†ê

1. **ÏàòÌèâ ÌôïÏû•**: MongoDB ÏÉ§Îî©ÏúºÎ°ú Î¨¥Ï†úÌïú ÌôïÏû•
2. **Ïú†Ïó∞Ìïú Ïä§ÌÇ§Îßà**: ÌåÄÎ≥Ñ Ïª§Ïä§ÌÖÄ ÌïÑÎìú Ï¶âÏãú Ï∂îÍ∞Ä
3. **ÏûêÎèô ÏïÑÏπ¥Ïù¥Îπô**: TTLÎ°ú Ïò§ÎûòÎêú Îç∞Ïù¥ÌÑ∞ ÏûêÎèô Ï†ïÎ¶¨
4. **Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî**: Change StreamsÎ°ú Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏

## Î™®ÎãàÌÑ∞ÎßÅ Î∞è Ïö¥ÏòÅ

### üìà Ï£ºÏöî Î™®ÎãàÌÑ∞ÎßÅ ÏßÄÌëú

```ruby
# app/services/monitoring_service.rb
class MonitoringService
  def self.health_check
    {
      mongodb: {
        connected: Mongoid.default_client.database_names.present?,
        document_count: Sprint.count + Task.count,
        storage_size: Mongoid.default_client.database.stats,
        average_query_time: measure_query_performance
      },
      postgresql: {
        connected: ActiveRecord::Base.connected?,
        record_count: Organization.count + User.count,
        connection_pool: ActiveRecord::Base.connection_pool.stat
      },
      sync_status: {
        pending_syncs: MongoSyncJob.queue_size,
        last_sync: Redis.get('last_sync_timestamp'),
        sync_errors: Redis.get('sync_error_count')
      }
    }
  end
  
  def self.alert_if_degraded
    health = health_check
    
    if health[:mongodb][:average_query_time] > 100
      AlertService.notify("MongoDB query performance degraded")
    end
    
    if health[:sync_status][:sync_errors].to_i > 10
      AlertService.notify("Data sync errors detected")
    end
  end
end
```

### üîß Ïö¥ÏòÅ Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

#### ÏùºÏùº Ï†êÍ≤Ä
- [ ] MongoDB ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÉÅÌÉú ÌôïÏù∏
- [ ] ÎèôÍ∏∞Ìôî ÌÅê ÏÉÅÌÉú ÌôïÏù∏
- [ ] TTL Ï†ïÎ¶¨ ÏûëÏóÖ ÌôïÏù∏
- [ ] ÏøºÎ¶¨ ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ

#### Ï£ºÍ∞Ñ Ï†êÍ≤Ä
- [ ] Ïä§ÌÜ†Î¶¨ÏßÄ ÏÇ¨Ïö©Îüâ Ï∂îÏù¥
- [ ] Ïù∏Îç±Ïä§ Ìö®Ïú®ÏÑ± Í≤ÄÌÜ†
- [ ] Î∞±ÏóÖ ÏÉÅÌÉú ÌôïÏù∏
- [ ] ÏÑ±Îä• Î©îÌä∏Î¶≠ Î∂ÑÏÑù

#### ÏõîÍ∞Ñ Ï†êÍ≤Ä
- [ ] TTL Ï†ïÏ±Ö Í≤ÄÌÜ†
- [ ] ÏïÑÏπ¥Ïù¥Î∏å Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù
- [ ] Ïö©Îüâ Í≥ÑÌöç ÏóÖÎç∞Ïù¥Ìä∏
- [ ] ÎπÑÏö© ÏµúÏ†ÅÌôî Í≤ÄÌÜ†

## Í≤∞Î°†

### üéØ ÌïµÏã¨ Ïù¥Ï†ê

1. **ÎèÖÎ¶Ω Task Ïª¨Î†âÏÖòÏùò Ïû•Ï†ê**
   - Ï†ÑÏ≤¥ Task Ï°∞Ìöå Î∞è ÌïÑÌÑ∞ÎßÅ Í∞ÄÎä•
   - ÌÅ¨Î°úÏä§ Sprint Î∂ÑÏÑù ÏßÄÏõê
   - Backlog Í¥ÄÎ¶¨ ÏµúÏ†ÅÌôî
   - Task Ïû¨ÏÇ¨Ïö© Î∞è Ïù¥Îèô Ïö©Ïù¥

2. **Î™ÖÌôïÌïú Ï±ÖÏûÑ Î∂ÑÎ¶¨**
   - PostgreSQL: Ï†ïÏ†Å Ï†ïÏùò, ÏÑ§Ï†ï, Í∂åÌïú
   - MongoDB: ÎèôÏ†Å Ïã§Ìñâ, ÌôúÎèô, Î©îÌä∏Î¶≠

3. **10Î∞∞ ÏÑ±Îä• Ìñ•ÏÉÅ**
   - Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏßÄÏõê
   - Î≥µÏû°Ìïú ÏßëÍ≥Ñ ÏµúÏ†ÅÌôî
   - ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨

4. **58% ÎπÑÏö© Ï†àÍ∞ê**
   - Ïù∏ÌîÑÎùº ÎπÑÏö© Í∞êÏÜå
   - Ïö¥ÏòÅ ÏûêÎèôÌôî
   - Ïä§ÌÜ†Î¶¨ÏßÄ ÏµúÏ†ÅÌôî

5. **Î¨¥Ìïú ÌôïÏû•ÏÑ±**
   - ÏàòÌèâÏ†Å ÌôïÏû• Í∞ÄÎä•
   - ÌåÄÎ≥Ñ Ïª§Ïä§ÌÑ∞ÎßàÏù¥Ïßï
   - Ïú†Ïó∞Ìïú ÏõåÌÅ¨ÌîåÎ°úÏö∞

### üöÄ ÏµúÏ¢Ö Í∂åÍ≥†ÏÇ¨Ìï≠

**"Ïã§Ìñâ Îç∞Ïù¥ÌÑ∞(Milestone, Sprint, Task)Î•º MongoDBÎ°ú Ïù¥Ï†Ñ"**ÌïòÎäî Ï†ÑÎûµÏùÄ:

1. **Ï¶âÍ∞ÅÏ†Å Ìö®Í≥º**: ÏÑ±Îä• Í∞úÏÑ†Í≥º ÎπÑÏö© Ï†àÍ∞ê Ï¶âÏãú Ïã§ÌòÑ
2. **ÎÇÆÏùÄ Î¶¨Ïä§ÌÅ¨**: Îã®Í≥ÑÏ†Å ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖòÏúºÎ°ú ÏïàÏ†ÑÏÑ± ÌôïÎ≥¥
3. **ÎØ∏Îûò ÎåÄÎπÑ**: ÌôïÏû•ÏÑ±Í≥º Ïú†Ïó∞ÏÑ±ÏúºÎ°ú ÏÑ±Ïû• ÏßÄÏõê
4. **ÌåÄ ÎßåÏ°±ÎèÑ**: Îπ†Î•∏ ÏùëÎãµ ÏÜçÎèÑÏôÄ Ïú†Ïó∞Ìïú Ïª§Ïä§ÌÑ∞ÎßàÏù¥Ïßï

Ïù¥Îäî Îã®ÏàúÌïú Í∏∞Ïà† Î≥ÄÍ≤ΩÏù¥ ÏïÑÎãå, **ÎπÑÏ¶àÎãàÏä§ ÎØºÏ≤©ÏÑ±ÏùÑ ÌöçÍ∏∞Ï†ÅÏúºÎ°ú Ìñ•ÏÉÅ**ÏãúÌÇ§Îäî Ï†ÑÎûµÏ†Å Í≤∞Ï†ïÏûÖÎãàÎã§.